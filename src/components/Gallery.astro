---
import { CldImage } from "astro-cloudinary";
import { getCldImageUrl } from "astro-cloudinary/helpers";
import cloudinary from "cloudinary";
import { cn } from "../utils/cn";
import Skeleton from "./Skeleton.astro";

type Props = {
  year: string;
  showOnlyPromotion?: boolean;
};

const { year, showOnlyPromotion } = Astro.props;

const cloudName = import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME as string;
const apiKey = import.meta.env.PUBLIC_CLOUDINARY_API_KEY as string | undefined;
const apiSecret = import.meta.env.CLOUDINARY_API_SECRET as string | undefined;

const getCloudinaryImages = async (folder: string): Promise<string[]> => {
  if (!apiKey || !apiSecret) {
    console.warn(
      "Cloudinary API credentials not found. Please provide imageIds prop or set PUBLIC_CLOUDINARY_API_KEY and CLOUDINARY_API_SECRET",
    );
    return [];
  }

  try {
    if (!apiKey || !apiSecret) {
      return [];
    }
    cloudinary.v2.config({
      cloud_name: cloudName,
      api_key: apiKey,
      api_secret: apiSecret,
    });

    const result = (await cloudinary.v2.search
      .expression(
        `folder:${folder}/*${showOnlyPromotion ? "AND tags:promotion" : ""}`,
      )
      .max_results(500)
      .execute()) as { resources: { public_id: string }[] };

    return result.resources.map(
      (resource: { public_id: string }) => resource.public_id,
    );
  } catch (error: unknown) {
    console.error("Error fetching images from Cloudinary:", error);
    return [];
  }
};

const imagePublicIds = await getCloudinaryImages(year);

const lightboxImages = imagePublicIds.map((publicId) => {
  return getCldImageUrl({
    src: publicId,
    width: 1920,
    quality: 90,
    format: "auto",
  });
});

const galleryId = `gallery-${year}`;

const isHigher = (index: number, pattern: number[], start?: number): boolean =>
  pattern.includes((index - (start ?? 0)) % (pattern.toReversed()[0] ?? 0));
---

{
  imagePublicIds.length > 0 && (
    <div class="grid grid-cols-2 md:grid-cols-4 gap-4" id={galleryId}>
      {imagePublicIds.map((publicId, index): JSX.Element => {
        return (
          <a
            href={lightboxImages[index]}
            class={cn(
              "relative glightbox rounded-lg overflow-hidden cursor-pointer hover:opacity-90 transition-opacity",
              index === 0 && "col-start-2 col-span-2 row-span-2",
              index === 1 && "col-start-1 w-2/3 mt-auto ml-auto",
              index === 2 && "col-start-1",
              isHigher(index, [0, 6, 14], 4) && "col-span-2 row-span-2",
              isHigher(index, [0, 6, 9, 12, 14]) && "row-span-2",
            )}
            data-gallery={galleryId}
            data-image-index={index}
          >
            <Skeleton class="absolute inset-0 w-full h-full z-0" />
            <CldImage
              src={publicId}
              width={1088}
              height={725}
              alt=""
              loading="lazy"
              class="w-full h-full object-cover relative z-10 opacity-0 transition-opacity duration-300"
              sizes="(max-width: 640px) 50vw, 20vw"
              crop="fill"
              quality={80}
              format="auto"
              data-image-index={index}
            />
          </a>
        );
      })}
    </div>
  )
}

<script define:vars={{ galleryId }} is:inline>
  (function () {
    // Handle image loading - hide skeleton when image loads
    function handleImageLoad() {
      const gallery = document.getElementById(galleryId);
      if (!gallery) return;

      const images = gallery.querySelectorAll("img[data-image-index]");
      images.forEach((img) => {
        const handleLoad = () => {
          img.classList.add("opacity-100");
          const skeleton = img.parentElement?.querySelector(".bg-gray-300");
          if (skeleton) {
            skeleton.style.display = "none";
          }
        };

        if (img.complete && img.naturalHeight !== 0) {
          // Image already loaded
          handleLoad();
        } else {
          // Wait for image to load
          img.addEventListener("load", handleLoad, { once: true });
          img.addEventListener("error", () => {
            // Hide skeleton even on error
            const skeleton = img.parentElement?.querySelector(".bg-gray-300");
            if (skeleton) {
              skeleton.style.display = "none";
            }
          }, { once: true });
        }
      });
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", handleImageLoad);
    } else {
      // DOM already loaded, but images might not be in DOM yet
      setTimeout(handleImageLoad, 0);
    }

    // Load GLightbox from CDN
    if (document.querySelector('script[src*="glightbox"]')) return;

    const script = document.createElement("script");
    script.src =
      "https://cdn.jsdelivr.net/npm/glightbox@3/dist/js/glightbox.min.js";
    script.onload = function () {
      if (window.GLightbox) {
        window.GLightbox({
          selector: `.glightbox[data-gallery="${galleryId}"]`,
        });
      }
    };
    document.head.appendChild(script);

    // Also load CSS if not already loaded
    if (!document.querySelector('link[href*="glightbox"]')) {
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href =
        "https://cdn.jsdelivr.net/npm/glightbox@3/dist/css/glightbox.min.css";
      document.head.appendChild(link);
    }
  })();
</script>
